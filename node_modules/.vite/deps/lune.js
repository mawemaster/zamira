import {
  __commonJS
} from "./chunk-4B2QHNJT.js";

// node_modules/lune/lib/julian.js
var require_julian = __commonJS({
  "node_modules/lune/lib/julian.js"(exports) {
    "use strict";
    function fromDate(date) {
      return date.getTime() / 864e5 + 24405875e-1;
    }
    function toDate(julian) {
      return new Date((julian - 24405875e-1) * 864e5);
    }
    exports.fromDate = fromDate;
    exports.toDate = toDate;
  }
});

// node_modules/lune/lib/lune.js
var require_lune = __commonJS({
  "node_modules/lune/lib/lune.js"(exports) {
    var julian = require_julian();
    var NEW = 0;
    var FIRST = 1;
    var FULL = 2;
    var LAST = 3;
    var PHASE_MASK = 3;
    var EPOCH = 24442385e-1;
    var ECLIPTIC_LONGITUDE_EPOCH = 278.83354;
    var ECLIPTIC_LONGITUDE_PERIGEE = 282.596403;
    var ECCENTRICITY = 0.016718;
    var SUN_SMAXIS = 149585e3;
    var SUN_ANGULAR_SIZE_SMAXIS = 0.533128;
    var MOON_MEAN_LONGITUDE_EPOCH = 64.975464;
    var MOON_MEAN_PERIGEE_EPOCH = 349.383063;
    var MOON_ECCENTRICITY = 0.0549;
    var MOON_SMAXIS = 384401;
    var MOON_ANGULAR_SIZE_SMAXIS = MOON_SMAXIS * 0.5181;
    var SYNODIC_MONTH = 29.53058868;
    function fixangle(a) {
      return a - 360 * Math.floor(a / 360);
    }
    function torad(d) {
      return Math.PI / 180 * d;
    }
    function todeg(r) {
      return 180 / Math.PI * r;
    }
    function dsin(d) {
      return Math.sin(torad(d));
    }
    function dcos(d) {
      return Math.cos(torad(d));
    }
    function kepler(m, ecc) {
      const epsilon = 1e-6;
      m = torad(m);
      let e = m;
      while (1) {
        const delta = e - ecc * Math.sin(e) - m;
        e -= delta / (1 - ecc * Math.cos(e));
        if (Math.abs(delta) <= epsilon) {
          break;
        }
      }
      return e;
    }
    function phase(phase_date) {
      if (!phase_date) {
        phase_date = /* @__PURE__ */ new Date();
      }
      phase_date = julian.fromDate(phase_date);
      const day = phase_date - EPOCH;
      const sun_mean_anomaly = 360 / 365.2422 * day + (ECLIPTIC_LONGITUDE_EPOCH - ECLIPTIC_LONGITUDE_PERIGEE);
      const sun_true_anomaly = 2 * todeg(Math.atan(
        Math.sqrt((1 + ECCENTRICITY) / (1 - ECCENTRICITY)) * Math.tan(0.5 * kepler(sun_mean_anomaly, ECCENTRICITY))
      ));
      const sun_ecliptic_longitude = ECLIPTIC_LONGITUDE_PERIGEE + sun_true_anomaly;
      const sun_orbital_distance_factor = (1 + ECCENTRICITY * dcos(sun_true_anomaly)) / (1 - ECCENTRICITY * ECCENTRICITY);
      const moon_mean_longitude = MOON_MEAN_LONGITUDE_EPOCH + 13.1763966 * day;
      const moon_mean_anomaly = moon_mean_longitude - 0.1114041 * day - MOON_MEAN_PERIGEE_EPOCH;
      const moon_evection = 1.2739 * dsin(
        2 * (moon_mean_longitude - sun_ecliptic_longitude) - moon_mean_anomaly
      );
      const moon_annual_equation = 0.1858 * dsin(sun_mean_anomaly);
      const moon_mp = moon_mean_anomaly + moon_evection - moon_annual_equation - 0.37 * dsin(sun_mean_anomaly);
      const moon_equation_center_correction = 6.2886 * dsin(moon_mp);
      const moon_corrected_longitude = moon_mean_longitude + moon_evection + moon_equation_center_correction - moon_annual_equation + 0.214 * dsin(2 * moon_mp);
      const moon_age = fixangle(
        moon_corrected_longitude - sun_ecliptic_longitude + 0.6583 * dsin(
          2 * (moon_corrected_longitude - sun_ecliptic_longitude)
        )
      );
      const moon_distance = MOON_SMAXIS * (1 - MOON_ECCENTRICITY * MOON_ECCENTRICITY) / (1 + MOON_ECCENTRICITY * dcos(moon_mp + moon_equation_center_correction));
      return {
        phase: 1 / 360 * moon_age,
        illuminated: 0.5 * (1 - dcos(moon_age)),
        age: SYNODIC_MONTH / 360 * moon_age,
        distance: moon_distance,
        angular_diameter: MOON_ANGULAR_SIZE_SMAXIS / moon_distance,
        sun_distance: SUN_SMAXIS / sun_orbital_distance_factor,
        sun_angular_diameter: SUN_ANGULAR_SIZE_SMAXIS * sun_orbital_distance_factor
      };
    }
    function meanphase(sdate, k) {
      const delta_t = (sdate - -22089456e5) / 864e5;
      const t = delta_t / 36525;
      return 241502075933e-5 + SYNODIC_MONTH * k + (1178e-7 - 155e-9 * t) * t * t + 33e-5 * dsin(166.56 + (132.87 - 9173e-6 * t) * t);
    }
    function truephase(k, tphase) {
      tphase = tphase & PHASE_MASK;
      k = k + 0.25 * tphase;
      const t = 1 / 1236.85 * k;
      let pt = 241502075933e-5 + SYNODIC_MONTH * k + (1178e-7 - 155e-9 * t) * t * t + 33e-5 * dsin(166.56 + (132.87 - 9173e-6 * t) * t);
      const m = 359.2242 + 29.10535608 * k - (333e-7 - 347e-8 * t) * t * t;
      const mprime = 306.0253 + 385.81691806 * k + (0.0107306 + 1236e-8 * t) * t * t;
      const f = 21.2964 + 390.67050646 * k - (16528e-7 - 239e-8 * t) * t * t;
      switch (tphase) {
        // new and full moon use one correction
        case NEW:
        case FULL:
          pt += (0.1734 - 393e-6 * t) * dsin(m) + 21e-4 * dsin(2 * m) - 0.4068 * dsin(mprime) + 0.0161 * dsin(2 * mprime) - 4e-4 * dsin(3 * mprime) + 0.0104 * dsin(2 * f) - 51e-4 * dsin(m + mprime) - 74e-4 * dsin(m - mprime) + 4e-4 * dsin(2 * f + m) - 4e-4 * dsin(2 * f - m) - 6e-4 * dsin(2 * f + mprime) + 1e-3 * dsin(2 * f - mprime) + 5e-4 * dsin(m + 2 * mprime);
          break;
        // first and last quarter moon use a different correction
        case FIRST:
        case LAST:
          pt += (0.1721 - 4e-4 * t) * dsin(m) + 21e-4 * dsin(2 * m) - 0.628 * dsin(mprime) + 89e-4 * dsin(2 * mprime) - 4e-4 * dsin(3 * mprime) + 79e-4 * dsin(2 * f) - 0.0119 * dsin(m + mprime) - 47e-4 * dsin(m - mprime) + 3e-4 * dsin(2 * f + m) - 4e-4 * dsin(2 * f - m) - 6e-4 * dsin(2 * f + mprime) + 21e-4 * dsin(2 * f - mprime) + 3e-4 * dsin(m + 2 * mprime) + 4e-4 * dsin(m - 2 * mprime) - 3e-4 * dsin(2 * m + mprime);
          const sign = tphase < FULL ? 1 : -1;
          pt += sign * (28e-4 - 4e-4 * dcos(m) + 3e-4 * dcos(mprime));
          break;
      }
      return julian.toDate(pt);
    }
    function phase_hunt(sdate) {
      if (!sdate) {
        sdate = /* @__PURE__ */ new Date();
      }
      let adate = new Date(sdate.getTime() - 45 * 864e5);
      let k1 = Math.floor(12.3685 * (adate.getFullYear() + 1 / 12 * adate.getMonth() - 1900));
      let nt1 = meanphase(adate.getTime(), k1);
      sdate = julian.fromDate(sdate);
      adate = nt1 + SYNODIC_MONTH;
      let k2 = k1 + 1;
      let nt2 = meanphase(adate, k2);
      while (nt1 > sdate || sdate >= nt2) {
        adate += SYNODIC_MONTH;
        k1++;
        k2++;
        nt1 = nt2;
        nt2 = meanphase(adate, k2);
      }
      return {
        new_date: truephase(k1, NEW),
        q1_date: truephase(k1, FIRST),
        full_date: truephase(k1, FULL),
        q3_date: truephase(k1, LAST),
        nextnew_date: truephase(k2, NEW)
      };
    }
    function phase_range(start, end, phase2) {
      start = start.getTime();
      end = end.getTime();
      let t = start - 45 * 864e5;
      let k;
      {
        const d = new Date(t);
        k = Math.floor(12.3685 * (d.getFullYear() + 1 / 12 * d.getMonth() - 1900));
      }
      let date = truephase(k, phase2);
      while (date.getTime() < start) {
        k++;
        date = truephase(k, phase2);
      }
      const list = [];
      while (date.getTime() <= end) {
        list.push(date);
        k++;
        date = truephase(k, phase2);
      }
      return list;
    }
    exports.PHASE_NEW = NEW;
    exports.PHASE_FIRST = FIRST;
    exports.PHASE_FULL = FULL;
    exports.PHASE_LAST = LAST;
    exports.phase = phase;
    exports.phase_hunt = phase_hunt;
    exports.phase_range = phase_range;
  }
});
export default require_lune();
//# sourceMappingURL=lune.js.map
